# 자바스크립트 LESSON 1

> "기록해서 나 주자"
> 더 좋은 Cheat sheet 이 아니라 내 머리와 글이다."
syntax: [블로그](https://medium.com/@jadetypehoon)

## 1장 BASIC
* 함수 == 타입 == 변수 == 1급함수
* 스트링은 str[1] = 'S' (X) 이런 접근은 안됨. read only.
* 콜백함수: 인자로 함수를 받아서 함수를 실행하는 구조에서 받는 함수를 뜻한다.

- - -
## 2장 object
* 모든 객체는 객체다.
* delete 키워드로 삭제를 할 수 있다. // iterater 작업시 문제가 생길 수도 있다.
* 메서드와 함수의 차이 ?
: 메서드 => 객체에게 동작을 수행하라고 하는것 객체에게 동작을 수행하라고 명령하지 않아도 된다. (왜냐하면 함수 자체가 함수객체) foo.sum 을 하면 프로퍼티로서의 정보만 반환하지만 foo.sum()을 하면 동작을 지시한것이다.
5. Built-in Object : 많이 쓰는 기능들을 미리 만들어둔 오브젝트 (= global Objects); new Boolean (123) 은 new Object (true) 와 같은 값을 반환한다.
6. Native ObjectHost Object(사용자 정의 객체)
7. JSON 방식, Constructor 방식
8. 함수 호출시, Parameter + this + Arguments를 전달받는다.

 프로토타입
1. prototype Object : 원형에다 추가하고 싶은 함수나 프로퍼티를 정의해서 쓰면된다. new로 생성된 인스턴스들은 접근할 수 있다. 공유한다.
2. 'prototype link'가 있고 '__proto__' 속성으로 표현된다.  이건 자신이 가지지 않은 함수나 프로퍼티를 조상을 쫒아가 반환해준다. new person으로 정의된 kim은 person.prototype.Object을 가르키고, person.prototype.Object는 Obejct Prototype Object을 가르키는 구조. 이 구조 순서대로 인터프렛의 흐름이 이어나가는걸 알아야 한다.

 컨택스트
실행중인 컨택스트를 callee 다른 컨택스트를 실행시키기 위해 필요한게 caller

 변수의 전달.
- 원시변수. string, null, Boolean, Number, String 은 PrimitiveType이고 고정된 메모리에 저장한다.
- 레퍼런스변수. Array, Object, Function은 레퍼런스를 가진다. 따라서 값이 값을 참고하는 복수의 레이블이 존재하면 값이 변하는걸 볼 수 있다.
- 원시타입은 객체형태의 메소드를 쓸때 표준 인스턴스 (ex: String)를 만들고호출하고 파괴하는 과정을 거친다. 이는 메모리에 상주하는 참조타입과 가장 큰 차이점이다. 이와같은 특징 때문에 string, number, boolean은 러닝 중 프로퍼티 작업을 할 수 없다. New 로 원시레퍼를 만들고 반환값을 활용하는 동작을 할 수는 있지만 혼란을 유발함.

호이스팅
- 위에서 부터 순서대로 코드를 읽다보면 정의되지 않은 시점에서도 호출이 가능한 자바스크립트의 구성이 이상해 보인다. 코드 위치에 상관없이 함수선언이 유효하게 되어버리는 함수 호이스팅 효과. 단 이건 function - 함수 정의식에만 해당 var func = func.. 이런 함수 표현식에는 미해당.

소코프체이닝
- << for, if는 유효범위에 무관. 오직 함수만이 유효범위의 단위>> 이 유효범위를 관리하는게 스코프. 스코프는 함수 실행 컨텍스트내에서 연결리스트의 형식으로 존재한다.

클로저
- 이미 생명주기가 끝난 외부 함수의 변수를 참조하는 함수. 컨텍스트가 끝날 함수 안에서 리턴을 함수로 던져줘서 내부내용이 조회가능하게 함.
return에 내부 함수(익명함수) 를 실행하도록 지정해라
function aaa {
var a;
mFuction (aaa) { console.log(a) };
return myFution();
}

클래스, 생성자, 메서드 구현하기
Blog 함수 객체의 blog1은 부모의 프로토타입객체 정보가 있고 부모의 프로토타입 객체는. Blog.prototype을 가르킨다.

블록함수
(funtion(){
	논리
})();
이런 방식을 통해서 논리를 전역이 아니라 수행후 파괴되는 형식을 구현한다. 협업떄 지켜야하는 충돌 방지

* 지역변수는 함수 내에서 전역변수보다 높은 우선순위

DOM 모델
element  타입은 DOM 노드 중에서 attribute 프로퍼티를 갖는 유일한 타입이다.

context는 실행환경에서 컨트롤되고 (5가지 원칙)  scope는 타이핑되는 모양새(함수)에 따른다.

. [''] 같은 호출이 콜러가 생기고 this가 생기는 부분. () 일땐 글로벌 컨텍스트를 계속 한다.

인프런 - 함수프로그래밍 수업
객체지향의 map, filter 등은 어레이엥 딸린 메서드 이기 떄문에 arraylike 한 것들 (div)에서 사용을 못함. 따로 구현한 함수기준의 함수형프로그래밍은 그게 가능. 함수를 먼저 구현하고 함수에 맞는 데이터를 집어넣는 다형성 구현.
document.querySelectAll('*'); ==> nodelist 객체지만 key value 기반이므로 돌아간다.


객체 지향은 데이터가 생겨야 기능을 수행
함수 지향은 함수가 먼저 존재하고 데이터가 들어온다. (평가시점이 유연)

외운다는 관점으로는 어차피 안된다. 원리를 인터프리트(평가)의 흐름을 읽는게 훨씬더 강력하고 자바스크립트- 함수형 프로그래밍의 본질에 가깝다. 잘 봐 한번

_. 엄격한 평가. 전부 다 돌려서 체크. 수평으로 진행.
L. 이렇게 파이프를 구성하면 val을 한개씩 던져서 마지막 수확단계에서 조건이 되는지 보는겁니다. 조건이 되면 끝내고 자원 최적화. 수직으로 진행

데이터 흐름 방식의 코드는 단순히 선언해주는 것만으로 병렬 처리가 가능해진다. (클러져 , 엘릭서)

var는 블록 상관없이 전역으로 가버리고 let은 블록내에서만 유효하다. 단지 반복정의 가능성만 다른게 아니다. let이 좋은건 그런 특성으로 인해 충돌이 없다는점.

함수는 함수프로토 받아서 선언된 것들
메서드는 객체 안에서 value로 선언된것들. method invocation. 메서드 안에선 this는 항상 그 객체!!! 중요 중요 평가시점의 this의 부모가 실제 부모다. 눈으로 보이는 현재 소속 상태가 중요한게 안다.

시각화 분야 괜찮다.. 정보를 처리해서 새로운 인식을 심어주는 일.

let은 블록스코프 기본적으로는 함수 스코프 준수
클로져 모듈 패턴 중요

function makeCounter () {
let private = 0;
return {
	increment : function() {
		private ++;
	},
	decrement: function () {
		private --;
	}, 	getValue : function () { 		return private;
	}
}
var a = makeCounter();
a.increment();

IAT 는 디버깅중요. 콘솔로그를 찍어서 검증. 슬라이드에 나온 모든 코드 다 이해. 중요개념. 클로져. 스코프 리커젼. 쉽지는 않아요. 내 손에 익숙해지게. 1주2주전에 준비. 난이도는 1차시험이 (오프토이x) 코플베이직 몇문제. 언더바 1문제. 처음보는 문제1개(어렵. 오프토이보다 어렵다) 총 3문제.

프리코드 캠프.

실행 컨텍스트는 함수단위로 생김
- (block 아님)
- 실행시에 생김 
this??!
글로벌이나 레벨 펑션안은 window. 직속부모가 window니까.
메소드로 불렸을떈? (오브젝트 키값이든 뭐든) 메서드 실행시점에서 직계 부모 obj.aaa ==> aaa 메서드안의 this는 obj다!
컨스트럭션안에 있는 this는 new로 호출될때의 인스턴스
call로 함수를 호출했을땐. aaa.call(me) ==> 여기 this는 me가 된다. this를 명시하여 넘기는게 이것!

forEach는 배열전용 (call로 컬렉터도 가능) for in은 객체에 적용되는 열거속성 회전. 대신 iterator 속성 상관없이 돈다. 그래서 포로토껄 가지고 오기도 한다.
for of는 객체에 적용되는 열거속성을 지정한것만 회전.



GIT stash 워킹에어리어 변경 + 스테이지드 변경 모두 저장하고 최근 러닝 상태로 돌림. 나중에 다시 돌림.



sudo lsof -i :"포트 번호"
sudo kill -9 "프로세스 번호" \


구축과정 정리
로그인 기능 > fail case > success case (use token. indentifying effect for one day) 토큰으로 지정된 헤더를 통해 클라이언트가 누구인지 확인할수있다. (use passport 그리고 passport-jwt. at middle ware) 미들웨어에서 이게 들어가면 user객체가 실제로 확인되면 user를 반환하고 아니면 null을 반환해서 다음 페이징을 구성. > passport를 확인하면 USERS 모델에서 팔로잉 팔로워 정보를 긁어서 res로 보냄.> apolo link graphql 로 뭘하는걸까.

공부보다 쇼핑이 재밌으면 언젠가 공부가 재밌어 지겠지.. 라고 기도 하는에 좋은걸까. 온라인 쇼핑은 안하는 생활원칙을 세우면 되는걸까. 만약 할 수 있다면 나는 공부가 세상에서 제일 재밌는 종족으로 나름 잘 살아갈 수 있겠지.

스테이트 . 상태저장!
컴포넌트. 작게 잘라서 구현!

햇갈리는 부분을 TIL 로 정리해서.


<<
WeWin 같은 케이스의 경우 개발자로서의 발전 노력을 보기위해 TIL이나 커밋활동들을 보더라. 서로 과정에 대해 오해하지 않고 시작할 수 있었으면 좋겠다. 힘들어도 포기하지 않겠다는 의지를 가지고 와주길 바랍니다.  14기부터 핫스팟 제공 (월 23). 오프라인은 3호점 공간사용가능. 채용회사에서 돈주고 코드스테이츠 데려감. 그래서 퀄리티있는 졸업조건제시함. 헬프데스크 기반. 오프라인이 장땡이 아니야. 10%-20% repeat. 본인 지원해서 하는 경우도 있고. 개인프로젝트는 옛날에 몇번 했고 요즘 없음. 초반 스프린트 내용 (서버, DB) 내용 부족 평가에서 81%만 되도 강제임. 잡서칭은 열심히 도움드리고 있어요. 자신도 있어요~! 코드스테이츠에서 보낸 시간들 시험, 결과물, 발표 그런것들에 대해서만 소개를 드리는것이기 때문에 신뢰할 수 있는것입니다. 돈 100-200 줘도 그런 과정이 채용 리스크를 줄여주는 솔루션으로 작동하고 있다. 이머시브에서 10% 정도는 창업을 하네.
>>

in 쓸때 array는 자동으로 숫자기반 인덱스가 되고 객체는 key값을 긁어온다.

class {
	var c
	methos a ( (b), var c)
	method b (get c)
}

a()하면 메소드 b에서 c를 찾을때 클래스 변수가 사용될까? 메소드 b를 호출한 메소드 a의 지역 변수 i가 사용될까? 클래스 변수를 사용한다.<< 메소드 내(b)에서 지역변수가 존재하지 않는다면 그 메소드가 소속된 클래스의 전역변수를 사용한다! 이것이 lexcal 이다. 충격과 스코프의 거지들아>>


설계를 잘해야한다~ 백엔드든 프론트엔드든. 그건 언어가 바뀌어도 변하지 않는 스킬

커밋해가는 습관 길러야 한다. 이거 버전관리가 안되니 존망;

<Async 이해>
- 핸들러..? 스레드 ( 비동기로 날린거 )가 서로 다르게 동작하는데. 중간에 입을 맞출 필요가 있다. 통신하기 위한 것이 핸들러. 웹페이지에 클릭하는 이벤트와 자바스크립트를 연동시키야 할 필요가 있다. 그럼 그때 구현한 클릭리스터는 핸들러다. 이벤트를 핸들! 하는 핸들러
- 동기작업들은 콜스택에 쌓여있는것들부터 하나하나 처리된다. 다 하는 동안 브라우저의 API 들이 콜백스택(excuiton context)에 하나씩 올려놓고 콜스택이 처리가 되면 이벤트루프가 작동. 콜백스택을 처리하게 된다.
-
5. this 바인딩
- 해당 함수가 객체의 함수(메소드) 로 호출되는지, 함수로 호출되는지에 따라 this 바인딩이 달라진다.
- 위 코드에서는 함수로 호출 되었으므로 this 는 전역 객체(window) 를 바인딩 한다.
excution 컨텍스트는 함수단위로 움직인다. 함수는 즉 콜스택이다. 컨텍스트에 담긴건 caller(근원), arguments, variable in (global, local), >>this<<

this 는 모든 함수 스코프 내에서 자동으로 정해지는 특별한 식별자.

setTimeOut 같은곳에 ( 즉 콜백함수를 비동기적으로 쓰는 ) 상황을 생각해보자. 비록 콜백함수를 method 형식으로 호출한다해도.. 비동기가 되면 일단 현재의 컨텍스트와는 동떨어져 있다가 나중에 다시 처리된다. 낙동강 오리알이다. 이럴땐 수동으로 지정해주지 않는이상 this는 글로벌이 된다.

this를 필요로 하는 클래스 메소드로 작업하는 경우, 명시해서 this를 콜백 함수에 바인딩할 수 있습니다, 인스턴스를 유지하기 위해. 즉 비동기함수에선 수동으로 지정하기위해 쓴다.


call, apply 가 컨텍스트와 arg를 전달하기 위해서 쓴다면 bind는 함수에 적용해서 컨텍스트와 들어오는 값을 미리정하는 역할.

var slice = Array.prototype.slice;

// ...

slice.apply(arguments);

이런 변태적인 활용도 가능한데.. 뭐하러 이러나
bind를 하면 망령이 깃들어서 그안에서 실행되는 this 는 모두 망령의 것이 기준이 된다. 일종의 템플릿 함수.

암묵적 전역 (implied globals) - var 안쓰고 변수 쓰다보면 다음 호출될때 var로 지정해버림

lexical 어휘의.. -> 정의될때 기준으로 scope를 지정한다.

MOCHA
- html로 하면 스크립트가 실행되면서 로드된것들을 테스트한다.
- npm test 로 cli 기준으로 볼 수도 있다.

싱글스레드 자바스크립트가 비동기작업을 하는 방법
- 스택을 다 비우고 나면 이벤트루프가 돌면서 task quere 돌입, webapi에 던지고 나면 그 결과는 테스크큐(콜백함수 저장공간)에 남고 테크스큐가 스택에 올라오면서 일이 마무리된다. 스택/테스트큐 하나를 다 비울때까지 한 가지 작업에 몰두한다. setOutTime(cb, 0)을 해도 바로 실행이 안되는 이유.


<< 화살표 함수>>
일반적 함수는 함수가 어떻게 호출되는냐에 따라 this가 결정된다. 이를 정적으로 할 수 있는게 화살표함수
화살표함수


x => this.x * x 에서 this는 글로벌이다.

화살표 함수는 call, applay, bind 메소드를 사용하여 this를 변경할 수 없다.



코딩카타?

<< 질문방법 >>
이런 에러코드를 봤다.
검색을 해보니 이런 내용이 있다.
그럼에도 해결이 안된다.
에러코드를 보아하니 이런게 의심됩니다.
어떻게 해결해야 할까요?

<<하이어링 어세스먼트>>
리피트는 셀프어세스먼트에서 다 준비가 된다. 열심히 해요.


-
<< 3년 동안의 비전을 가져야 한다>>
매번 이걸 되살펴보는



<< 조언 >>
글 쓰는 개발자가 되세요(레어함) 무거운 엉덩이, 적극적인 태도로 표현해야한다. 스스로에게 힘을 줘야 한다. 코드스테이츠는 협업에 촛점을 둔다. (여기 BM의 핵심). 함께 일하고 싶은 사람이 촛점. 클린코드에 대한 열망이 나를 키웠다.




<목표>
1일 1커밋, 1일 TIL;; ? 해봐;


메모
조직문화에서 자유, 여행을 좋아함..

이머시브에서 얻어갈것 -
프로그래밍을 하다가 노마드로..
자유로운 선택을 위해서 대부분 풀스택지향.
다들 열정이 넘침.

이은지님. 디지털 노마드 여행.
조희정님. 디지털 노마드 여행.
황종옥님. 누나가 관련일을 해서 시작.
김정은님. 자유를 찾아서.
강태훈님. 자유를 찾서. 조직이 깝깝해서.
영희님님. R를 통해서. 해외


박중홍; 구일모; 이승재; 오승윤CS;

질문, 세션요청은 연구를 통해서 진행. 템플릿 및 라베을 설정하자.
질문할것도 없이 의무로 해야한다면 자신이 찾은 레퍼런스 2~3개 정도를 올려도 된다.

https://github.com/Dankimhaejun/im14-2019-07-immersive-prep.git

외부함수의 컨텍스트에 접근할 수 있는 내부함수 === 클로저라 한다. (외부를 참조 안하면 클로저가 아니다) 외부함수가 실행되더라도 남아있다. 
<테스트>
테스트를 하면 it 안의 지시는 전체 describe 처리된 다음 돈다. 그래서 var를 쓰면 잘못된 방식으로 처리가 된다.


마음에 드는 사람들?
<< 확실하게 논리적으로 이론을 세우고 확실하지 않은건 시도도 하지 않는다. 내가 아는것만 해서 풀어야지 문
