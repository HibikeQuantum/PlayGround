# 유닉스 고급 쉘에 나오는 운영팁

#Devops/language/Bash #project #book/Done

---

1. `cp` 같은걸 사용하는 배치를 작성을 할때 항상 --verbose 옵션을 사용하기를 권장. 어차피 로그를 열어볼일은 잘 없지만, 열어보게 될 일이 생길땐 최대한 자세한 내용을 원한게 될테니까 말이다.

2. 배치쉘이 1초간에 같은 이름으로 여러 파일을 작성가능성이 있다. 이에 대한 예외 처리를 통해 이름 뒤에 시퀀스를 붙이거나 천천히 실행하도록 조치를 해야한다.

3. 파일시스템에 대한 염려없이 일단 로그를 저장하게 만든 시스템이 다운되는 경우가 많다.  그래서 운영을 할때 파일이 자동으로 증가하는 영역이 있다면 미리 삭제하는 배치작업을 만들어놓는게 매너.

4. `rm -rf $tmpDir/` 이렇게 코드를 짰는데 $tmpDir 에 참조할 변수가 없으면 `rm -rf /`		이 된다. 정말 조심 이런 에러를 막기위해 set -u 를 하면 참조실패할때 스크립트를 종료시켜버리는 기능이 존재한다.  → Shell option

5. 웹서버를 공격할때 RFC(Request for Comments)를 위반한 요청이 온다. (RFC에 기반하여 HTML 프로토콜이 작성되었다) 그러면 첫번째 요청의 헤드가 이상하게 온다. (그럼 웹 서비스 로그도 이상하게 남겠지) 그래서 로그를 감시할때 좀 예외케이스를 주의할 필요가 있다.  광 범위하게 500번대 에러를 돌려주는 리퀘스트를 필터링 하려면 awk ‘$NF-1) >= 500 {print $}

6. 간단한 연산은 awk에서 진행한 다음 출력 할 수 있다. 1) 컬럼의 위치를 바꾸것나 2) 특정 값만 처리하기 

7. txt 파일을 브라우저로 보고 싶을땐 html 형식으로 바꿔야하는데.  이스케이프 문자로 변환을 해주는 작업을 해야한다. 쉘로 할 수도 있고 스크립트 언어에도 전용 함수가 있다. 반대로 html 

8. html 파일을 다루게 되면 이게 어떤 인코딩을 쓰는지 meta 값을 sed + iconv 로 컨버트 하는 과정이 필요하다. 메타값이 없으면 UTF-8이 기본이다.

9. `trap 'echo “Try Count: $count”’ USR1` 이렇게 USR1 sig를 받으면 안에서 변수를 출력하는 구조를 통해 쉘을  프로그램 처럼 더 독립적이고 인터렉티브하게 쓸 수 있다. 항상 포어그라운드로만 쓴다고 생각할 필요는 없다. 이건 설정 파일을 다시 읽게하는데도 쓸 수 있다. `trap ‘loadconf’ HUP` , `trap 'rm -f $tempfile' EXIT` 이렇게 중간에 킬당하거나 종료시 파일을 삭제 하고 종료되도록 할 수도 있다. 

10. 톰캣 startup.sh 는 catalina.sh를 래핑하잖아. 그런 방식을 쓰자. 이때 

	1. `./`

		* 포크를 통해 실행하고 기다린다. (별도의 프로세스가 생성된다.)

		* 단순 기동에는 쓰지만 상주프로그램에는 쓰지 않는다. 

		* 이런 실행의 절차를 표현하는 folk, exec, exit은 시스템 콜로 명령어가 아니다.  

	2. `exec ./`은 다르다. 이렇게 하면 직접 exec를 콜을 발행한다.  직접 실행하면 기다리지만 exec로 하면 기다리지 않는다. 즉 cpu를 다른 프로세스한테 줄 수 있다.  여러개의 프로세스가 실행된다고 생각하면 리소스를 아끼기 위해 exec

11. 넘겨줄 인자가 쪼개지는게 걱정일땐 `$@` 대신  `”$@“` 이렇게 쓴다.

12. 작업이 CPU바운드 처리인지, IO바운드 처리인지, 캐시, 메모리 바운드 일수도 있다.  성능을 time 명령어로 계측한다.

13. 소수점 계산에 쓰는 bc echo `“scale=2; (1.1 + 2.2) / 3.3” | bc` 이렇게

14. 맥의 echo는 bash echo랑 다르다.  `name - s`로 OS를 파악한다음 /bin/echo 로 대체해준다. 오픈 소스에서 여러 OS를 사용할 것을 염두한다면 이렇게 명령어를 치환해주는 작업이 필요하다. 

15. 매번 `>>`으로 리다이렉트 하는게 번거롭고 가독성에 좋지 않다.

```

{

 echo

 mv

 cp

} >> out.log

```

소괄호도 이렇게 쓸 수 있다. 다만 다이렉트 위치만 독립적으로 움직일 뿐이다.

짤막한 명령어들을 한줄로 표현한다면 이렇게 쓰는걸 추천.

16. diff 나 grep 들은 사용자가 의도한 결과로 보지 않은 경우 0이 아닌 값으로 종료한다. 따라서 이걸 회피할 필요가 있는데 `set +e`같은게 거추장 스럽다면 `diff File1 File2 > diff.txt ||:` 이렇게 쓴다. null 명령어는 은 언제나 0이다. true 도된다. 한편으론 `e`값을 임의으로 무시하는 코딩은 권장되지 않기도 한다. 예외처리를 다 하는게 정답일것이다. 

17. `Somthting.1 % Somthting%.2` 이렇게 미리 아이피 대역을 입력해놓은 파일을 열어서 `for ipaddr in $(sed “s/somthing/$1/“ target.lst` 이렇게 이터레이트 하면 손 쉽게 반복되는 작업을 줄일 수 있다. 이렇게까지 안해도 `seq 1 1 255`를 하면 필요한 숫자들을 구할 수도 있다. 매번 expr로 변수를 증가시키는 방법도 있지만 seq가 성능이 좋다. 10배. 

18. 스크립트 실행의 실패를 염두하고 작성한다. `cd “$dir” && ./script.sh`

19. `LANG=C /sbin/ifconfig \` 영어로 직접 명령어 호출, \는 줄바꿈을 뜻한다.

20. 스크립트에 유저 종속성을 걸어놓는게 좋은 패턴이다. `$(id -nu)`  와 지정된 변수와 비교하면 된다.

21. who를 통해 현재 로그인 중인 유저를 알 수 있다. 셧다운을 직접하지 말고 쉘로 만들어놓고 점검할 사안들을 체크하는 스크립트를 운영하면 좋다. 실행중인 프로그램 && 로그인 유저 조건을 거는 것이다. GUI 콘솔도 카운팅, GUI 콘솔에서 연 터미널도 카운팅 즉 3개의 터미널 부터 다른 유저로 보면된다.

22. 서버에 있는 파일? 패키지에 있는건지, 직접 작성한것인지? `rpm -qf “$1”` 파일명에서 속한 RPM 패키지명 획득(레드햇 계열)

23. 설치할 패키지를 파일로 관리하고 `yum -y install $pkg` 이렇게 한다. 요즘은 이렇게 하지 않아도 데브옵스한 방법으로 할 방법이 많다. 

24. 특정프로세스가 존재하는지 제한값을 넘었는지 감시하는 스크립트를 돌려 놓는다. 방법은 여러가지다. 외부에서 메트릭을 잡든 내부에서 잡아서 외부로 알리든 둘다 하는것도 방법일수도 있겠지. `(ps -ax -o command | grep “$commname” | grep -v “^grep” | wc -l)`  주기적으로 실행하는 쉘이라면 이런게 필요하다. 프로세스가 무한 펜딩되거나 작업이 지연되는걸 파악할 수 있으니까.

25. 감시하고 자동 재실행(service httpd start)하는 구조도 가능. 다만 웹서버같은것에만 적용해야한다. DB는 멈춘 이유가 다르게 존재할 수 있다. 그래서 감시만 하고 실행은 하지 않게 하는게 굿 프랙티스. 

26. ping 을 받을지 안받을지 지정하는 방법 `echo “1” > /proc/sys/net/ipv4/icmp***echo***ignore_all`

27. 소규모 형태의 사이트에서나 쓸만한 방법 일반적으론 솔루션을 활용해서 서버를 관리한다.

28. 스탠다드 아웃풋을 read에 연결해놓고 while로 쓰면 실시간 감시 프로그램을 만들 수 있다.

29. 핑, 프로세스, 로그, HTTP 감시.. 여러가지 할 수 있고 백엔드 서버의 경우 스왑의 여부를 검사하는게 중요하다. DB의 경우 커넥션에러가 발생하지 않도록 다운의 징조 (커넥션 풀 고갈)을 감시한다. 

30. bash를 중심으로 설명을 했다. BSD나 최소버전의 리눅스엔 bash가 없다. 데비안에선 `sudo apt-get install bash` ,  레드햇 `yum install bash`,